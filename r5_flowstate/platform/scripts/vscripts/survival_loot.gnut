global function SV_Survival_Loot_Init
global function GetRandomLootArray
global function LootTypeHasAnyChanceToSpawn
global function SpawnLoot
global function SURVIVAL_PlaceGroundItems
global function SURVIVAL_ThrowLootFromPoint
global function SURVIVAL_PlayerPickedupItem
global function EquipAttachments_Internal
global function PlayPickupSound
global function AddRoundsToWeapon
global function SURVIVAL_TryTakeDefaultMeleePrimary
global function TrackingVision_CreatePOIForPickedUpLoot
global function SURVIVAL_GiveMainWeapon
global function GetThrowOrigin
global function SpawnGenericLoot
global function SetItemSpawnSource
global function AddToDeathBox
global function SURVIVAL_CreateDeathBox
global function FakePhysicsThrow
global function SURVIVAL_GivePlayerEquipment
global function SpawnWeaponAndAmmo
global function SpawnArmor
global function SpawnNothing
global function SpawnAllOptics
global function SURVIVAL_DropMainWeapon
global function SURVIVAL_DropBackpackItem
global function Loot_AddCallback_OnPlayerLootPickup
global function SURVIVAL_NumItemsInInventory
global function ResetPlayerInventory
global function GetAllLootZones
global function GetLootHotZone
global function SURVIVAL_LootTierForLootGroup
global function InfiniteAmmoEnabled
global function Survival_SetInventoryEnabled
global function LootZones_GetRefForOrigin
global function CodeCallback_WeaponDropped
global function CodeCallback_WeaponLoadoutPickup
global function PlayerThrowLoot
global function SwitchingTestIdk
global function GetNextOrdnance
global function SwitchPlayerToOrdnance

const int GIVE_FULL_AMMO_MARKER = 1337 // I hate this

global const LOOT_TRACE = 10
global const LOOT_COLLISION_GROUP = 1

global enum eSpawnSource
{
	PLAYER_DROP
	DROPPOD
}
global enum eLootZoneClass
{
	ZONE_NONE,
	ZONE_LOW,
	ZONE_MEDIUM,
	ZONE_HIGH,
	ZONE_HOTZONE,
	ZONE_LOOT_VAULT
}

struct {
	array<LootZone> lootZones
	LootZone hotZone
	table<vector, array<string> > vaultLootSpawned
	array<entity> spawnedAmmoStacks
} file

bool function InfiniteAmmoEnabled()
{
	return GetCurrentPlaylistVarBool( "survival_infinite_ammo", false )
}

void function SV_Survival_Loot_Init()
{
	// AddSpawnCallbackEditorClass( "script_ref", "info_survival_weapon_location", OnGroundLootSpawned )

	AddClientCommandCallback( "Sur_DropEquipment", ClientCommand_Sur_DropEquipment )
	AddClientCommandCallback( "Sur_DropBackpackItem", ClientCommand_Sur_DropBackpackItem )

	AddClientCommandCallback( "Sur_EquipAttachment", ClientCommand_Sur_EquipAttachment )
	AddClientCommandCallback( "Sur_UnequipAttachment", ClientCommand_Sur_UnequipAttachment )

	AddClientCommandCallback( "Sur_TransferAttachment", ClientCommand_Sur_TransferAttachment )

	AddClientCommandCallback( "Sur_SwapPrimaryPositions", ClientCommand_Sur_SwapPrimaryPositions )

	AddClientCommandCallback( "BackpackOpened", ClientCommand_BackpackOpened )
	AddClientCommandCallback( "BackpackClosed", ClientCommand_BackpackClosed )

	// AddClientCommandCallback( "weaponSelectPrimary0", ClientCommand_PlayerSwitchedWeapons )
	// AddClientCommandCallback( "weaponSelectPrimary1", ClientCommand_PlayerSwitchedWeapons )
	
	AddClientCommandCallback( "Sur_SwitchToOrdnance", ClientCommand_Sur_SwitchToOrdnance )
	AddClientCommandCallback( "Sur_SwapToNextOrdnance", ClientCommand_Sur_SwapToNextOrdnance )
	AddClientCommandCallback( "Sur_EquipOrdnance", ClientCommand_Sur_EquipOrdnance )

	AddClientCommandCallback( "PickupSurvivalItem", ClientCommand_PickupSurvivalItem )
	AddClientCommandCallback( "SwapSurvivalItem", ClientCommand_SwapSurvivalItem )

	SetCallback_OnPlayerReload( OnWeaponReload )
	AddCallback_OnWeaponAttack( OnWeaponAttack_OrdnanceControl )

	FlagInit( "Survival_LootSpawned", false )
	FlagInit( "Survival_LootZonesLoaded", false)

	AddCallback_EntitiesDidLoad( LoadLootZonesForMap )

	RegisterSignal( "SwitchToOrdnance" )
	RegisterSignal( "SwapToNextOrdnance" )
	RegisterSignal( "EndTyThread" )
	RegisterSignal( "OnItemPickup" )
	PrecacheParticleSystem( $"P_wpn_lasercannon_aim_short_blue" )
	PrecacheParticleSystem( $"P_wpn_lasercannon_aim" )
	AddPingCallbackForType( ePingType.LOOT, TryThankForLoot )

	// file.lootDataTable = GetDataTable( $"datatable/survival_loot.rpak" )
}

void function LoadLootZonesForMap()
{
	array<entity> lzEnts = GetEntArrayByClass_Expensive( "script_ref" )

	foreach ( lzEnt in lzEnts )
	{
		if ( GetEditorClass( lzEnt ) != "info_survival_loot_zone" )
			continue

		LootZone zone
		zone.origin = lzEnt.GetOrigin()
		zone.radius = float(lzEnt.kv.script_radius)
		zone.height = float(lzEnt.kv.script_height)
		zone.ref = string(lzEnt.kv.zone_class)

		switch ( lzEnt.kv.zone_class )
		{
			case "zone_hotzone":
				zone.zoneClass = eLootZoneClass.ZONE_HOTZONE
				break
			case "zone_high":
				zone.zoneClass = eLootZoneClass.ZONE_HIGH
				break
			case "zone_medium":
			case "Desertlands_Train_Station":
				zone.zoneClass = eLootZoneClass.ZONE_MEDIUM
				break
			case "data_knife_vault":
				zone.zoneClass = eLootZoneClass.ZONE_LOOT_VAULT
				break
			default:
				zone.zoneClass = eLootZoneClass.ZONE_NONE
		}

		file.lootZones.append( zone )
	}

	if ( file.lootZones.len() == 0 )
	{
		FlagSet( "Survival_LootZonesLoaded" )
		return
	}

	if ( !GetCurrentPlaylistVarBool( "ground_loot_enable", true ) || !GetCurrentPlaylistVarBool( "hot_zone_enable", true ) )
	{
		FlagSet( "Survival_LootZonesLoaded" )
		return
	}
	array<LootZone> hotZones

	lzEnts = GetEntArrayByClass_Expensive( "script_ref" )

	foreach ( lzEnt in lzEnts )
	{
		if ( GetEditorClass( lzEnt ) != "info_survival_loot_hotzone" )
			continue

		LootZone zone
		zone.origin = lzEnt.GetOrigin()
		zone.radius = float(lzEnt.kv.script_radius)
		zone.height = float(lzEnt.kv.script_height)
		zone.zoneClass = eLootZoneClass.ZONE_HOTZONE

		hotZones.append( zone )
	}

	if ( hotZones.len() == 0 )
	{
		FlagSet( "Survival_LootZonesLoaded" )
		return
	}

	// The hotzone
	LootZone hotZone = hotZones.getrandom()

	file.hotZone.origin = hotZone.origin
	file.hotZone.radius = hotZone.radius
	file.hotZone.height = hotZone.height
	file.hotZone.zoneClass = eLootZoneClass.ZONE_HOTZONE

	FlagSet( "Survival_LootZonesLoaded" )
	//printt("Generated Loot Zones!", file.lootZones.len())
}

void function OnWeaponReload( entity player )
{
	entity weapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )

	if ( RandomFloat( 1.0 ) >= 0.95 ) // 5% chance to say the reloading voice line
		PlayBattleChatterLineToSpeakerAndTeam( player, "bc_reload" )

	if ( !InfiniteAmmoEnabled() )
	{
		int ammoType = weapon.GetWeaponAmmoPoolType()
		string ammoRef = AmmoType_GetRefFromIndex( ammoType )

		int currentAmmo = weapon.GetWeaponPrimaryClipCount()
		int maxAmmo = weapon.UsesClipsForAmmo() ? weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) : weapon.GetWeaponPrimaryAmmoCountMax( weapon.GetActiveAmmoSource() )

		int requiredAmmo = maxAmmo - currentAmmo

		int ammoInInventory = SURVIVAL_CountItemsInInventory( player, ammoRef )

		int ammoToRemove = int( min( requiredAmmo, ammoInInventory ) )

		// printt("!!! Survival.OnWeaponReload", ammoRef, currentAmmo, maxAmmo, requiredAmmo, ammoInInventory, ammoToRemove )

		SURVIVAL_RemoveFromPlayerInventory( player, ammoRef, ammoToRemove )
	}
}

string function GetNextOrdnance( entity player, string currentOrdnance = "" )
{
	array<string> allPlayerOrdnances = SURVIVAL_GetAllPlayerOrdnance( player )

	if ( allPlayerOrdnances.len() == 0 )
		return ""

	int ornull currentOrdnancePos = 0
	if ( currentOrdnance != "" )
	{
		currentOrdnancePos = allPlayerOrdnances.find( currentOrdnance )
		if ( currentOrdnancePos == null )
			currentOrdnancePos = 0
	}

	expect int( currentOrdnancePos )

	int nextOrdnancePos = currentOrdnancePos + 1
	if ( nextOrdnancePos >= allPlayerOrdnances.len() )
		nextOrdnancePos = 0

	return allPlayerOrdnances[nextOrdnancePos]
}

void function SwitchPlayerToOrdnance( entity player, string newOrdnance )
{
	// printt("Player switched to ordnance")
	entity heldOrdnance = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_ANTI_TITAN )
	bool shouldSelect = false

	if ( IsValid( heldOrdnance ) )
	{
		if ( heldOrdnance.GetWeaponClassName() == newOrdnance )
			return // Already switched to it

		shouldSelect = ( player.GetActiveWeapon( eActiveInventorySlot.mainHand ) == heldOrdnance ) // Currently selected
			|| ( player.GetActiveWeapon( eActiveInventorySlot.mainHand ) == null ) // Nothing selected

		player.TakeWeaponByEntNow( heldOrdnance )
		heldOrdnance = null
	}

	player.GiveWeapon( newOrdnance, WEAPON_INVENTORY_SLOT_ANTI_TITAN, ["survival_finite_ordnance"] )
	entity ordnance = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_ANTI_TITAN )

	AddRoundsToWeapon( player, ordnance, SURVIVAL_CountItemsInInventory( player, newOrdnance ) )

	if ( shouldSelect )
		player.SetActiveWeaponBySlot( eActiveInventorySlot.mainHand, WEAPON_INVENTORY_SLOT_ANTI_TITAN )
}

void function OnWeaponAttack_OrdnanceControl( entity player, entity weapon, string weaponName, int ammoUsed, vector attackOrigin, vector attackDir )
{
	if ( !IsValid( player ) || !IsValid( weapon ) )
		return

	LootData data = SURVIVAL_GetLootDataFromWeapon( weapon )

	if ( data.lootType != eLootType.ORDNANCE )
		return
	
	// printt("ClientCommand_Sur_OrdnanceControl")
	SURVIVAL_RemoveFromPlayerInventory( player, data.ref, 1 )

	if ( SURVIVAL_CountItemsInInventory( player, data.ref ) == 0 )
	{
		string nextOrdnance = GetNextOrdnance( player, data.ref )
		if ( nextOrdnance != "" )
			thread function () : ( player, weapon, nextOrdnance )
			{
				wait weapon.GetWeaponSettingFloat(eWeaponVar.toss_time)
				if( !IsValid( player ) )
					return
				SwitchPlayerToOrdnance( player, nextOrdnance )
			}()
		else thread function () : ( player, weapon, nextOrdnance )
			{
				wait weapon.GetWeaponSettingFloat(eWeaponVar.toss_time)
				if( !IsValid( player ) )
					return
				player.SetActiveWeaponBySlot( eActiveInventorySlot.mainHand, WEAPON_INVENTORY_SLOT_PRIMARY_2 )
			}()
	}
}

bool function ClientCommand_Sur_SwitchToOrdnance( entity player, array<string> args )
{
	printt("ClientCommand_Sur_SwitchToOrdnance")
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 1 )
		return true

	if ( !SURVIVAL_PlayerCanSwitchOrdnance( player ) )
		return true

	int ordnanceIdx = int( args[0] )

	if ( ordnanceIdx == -1 )
		return true

	LootData ordnanceLootData = SURVIVAL_Loot_GetLootDataByIndex( ordnanceIdx )

	if ( ordnanceLootData.lootType != eLootType.ORDNANCE )
		return true

	int ordnanceCount = SURVIVAL_CountItemsInInventory( player, ordnanceLootData.ref )

	if ( ordnanceCount == 0 )
		return true

	SwitchPlayerToOrdnance( player, ordnanceLootData.ref )
	player.Signal( "SwitchToOrdnance" )

	return true
}

bool function ClientCommand_Sur_EquipOrdnance( entity player, array<string> args )
{
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 1 )
		return true

	if ( !SURVIVAL_PlayerCanSwitchOrdnance( player ) )
		return true

	string ordnanceRef = args[0]

	if ( !SURVIVAL_Loot_IsRefValid( ordnanceRef ) )
		return true

	LootData ordnanceLootData = SURVIVAL_Loot_GetLootDataByRef( ordnanceRef )

	if ( ordnanceLootData.lootType != eLootType.ORDNANCE )
		return true

	int ordnanceCount = SURVIVAL_CountItemsInInventory( player, ordnanceLootData.ref )

	if ( ordnanceCount == 0 )
		return true

	SwitchPlayerToOrdnance( player, ordnanceLootData.ref )

	return true
}

bool function ClientCommand_Sur_SwapToNextOrdnance( entity player, array<string> args )
{
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( !SURVIVAL_PlayerCanSwitchOrdnance( player ) )
		return true

	entity heldOrdnance = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_ANTI_TITAN )
	string currentOrdnance = ""
	if ( IsValid( heldOrdnance ) )
		currentOrdnance = heldOrdnance.GetWeaponClassName()

	string nextOrdnance = GetNextOrdnance( player, currentOrdnance )
	if ( nextOrdnance != "" )
	{
		SwitchPlayerToOrdnance( player, nextOrdnance )
		player.Signal( "SwapToNextOrdnance" )
	}

	return true
}

bool function ClientCommand_PickupSurvivalItem( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_pickup_item", true ) )
		return true

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 2 )
		return true

	int lootEntEEH = int( args[0] )
	if ( lootEntEEH == -1 )
		return true

	int pickupFlags = int( args[1] )
	if ( pickupFlags == -1 )
		return true

	entity lootEnt = GetEntityFromEncodedEHandle( lootEntEEH )
	if ( !IsValid( lootEnt ) )
		return true

	if ( lootEnt.GetNetworkedClassName() != "prop_survival" )
		return true

	if ( !SURVIVAL_CanPlayerPickup( player, lootEnt ) && GameRules_GetGameMode() != "fs_aimtrainer")
		return true

	entity deathBox = null
	if ( args.len() > 2 )
	{
		int deathBoxEEH = int( args[2] )
		if ( deathBoxEEH  == -1 )
			return true

		deathBox = GetEntityFromEncodedEHandle( deathBoxEEH )
		if ( !IsValid( deathBox ) )
			return true

		if ( deathBox.GetNetworkedClassName() != "prop_death_box" )
			return true

		if ( !deathBox.GetLinkEntArray().contains( lootEnt ) )
			return true
		
		if( GameRules_GetGameMode() == "fs_aimtrainer" )
		{
			thread function() : (deathBox)
			{
				WaitFrame()
				if(IsValid(deathBox))
					deathBox.Destroy()
			}()
			return true
		}
	}

	Survival_PickupItem( lootEnt, player, pickupFlags, deathBox )

	if ( deathBox != null )
	{
		if ( deathBox.GetLinkEntArray().len() == 0 )
		{
			deathBox.Dissolve( ENTITY_DISSOLVE_CORE, <0, 0, 0>, 500 )

			thread function() : ( deathBox )
			{
				wait 1.0
				
				if( !IsValid( deathBox ) )
					return
			
				entity boxPhysics = deathBox.GetParent()
			
				if( IsValid( boxPhysics ) && boxPhysics.GetClassName() == "prop_physics" )
				{
					deathBox.ClearParent()
					boxPhysics.Destroy()
				}

				wait 2.0
				
				if ( IsValid( deathBox ) )
					deathBox.Destroy()
			}()
		}
		else
			UpdateDeathBoxHighlight( deathBox )
	}

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_SwapSurvivalItem( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_swap_item", true ) )
		return true

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 2 )
		return true

	int backpackSlot = int( args[0] )
	if ( backpackSlot < 0 )
		return true

	array<ConsumableInventoryItem> playerInventory = player.ConsumableInventory_Get()
	if ( playerInventory.len() <= backpackSlot )
		return true

	ConsumableInventoryItem itemToThrow = playerInventory[backpackSlot]
	LootData itemToThrowData = SURVIVAL_Loot_GetLootDataByIndex( itemToThrow.type )

	int lootEntEEH = int( args[1] )
	if ( lootEntEEH == -1 )
		return true

	entity lootEnt = GetEntityFromEncodedEHandle( lootEntEEH )
	if ( !IsValid( lootEnt ) )
		return true

	if ( lootEnt.GetNetworkedClassName() != "prop_survival" )
		return true

	if ( !SURVIVAL_CanPlayerPickup( player, lootEnt ) )
		return true

	entity deathBox = null
	if ( args.len() > 2 )
	{
		int deathBoxEEH = int( args[2] )
		if ( deathBoxEEH  == -1 )
			return true

		deathBox = GetEntityFromEncodedEHandle( deathBoxEEH )
		if ( !IsValid( deathBox ) )
			return true

		if ( deathBox.GetNetworkedClassName() != "prop_death_box" )
			return true

		if ( !deathBox.GetLinkEntArray().contains( lootEnt ) )
			return true
	}

	if ( deathBox != null )
	{
		SURVIVAL_RemoveFromPlayerInventory( player, itemToThrowData.ref, itemToThrow.count )

		entity modLoot = SpawnGenericLoot( itemToThrowData.ref, deathBox.GetOrigin(), deathBox.GetAngles(), itemToThrow.count )
		AddToDeathBox( modLoot, deathBox )
	}
	else
		SURVIVAL_DropBackpackItem( player, itemToThrowData.ref, itemToThrow.count )

	Survival_PickupItem( lootEnt, player, 0, deathBox )

	if ( deathBox != null )
	{
		if ( deathBox.GetLinkEntArray().len() == 0 )
		{
			deathBox.Dissolve( ENTITY_DISSOLVE_CORE, <0, 0, 0>, 500 )

			thread function() : ( deathBox )
			{
				wait 1.0
				
				if( !IsValid( deathBox ) )
					return
			
				entity boxPhysics = deathBox.GetParent()
			
				if( IsValid( boxPhysics ) && boxPhysics.GetClassName() == "prop_physics" )
				{
					deathBox.ClearParent()
					boxPhysics.Destroy()
				}

				wait 2.0
				
				if ( IsValid( deathBox ) )
					deathBox.Destroy()
			}()
		}
		else
			UpdateDeathBoxHighlight( deathBox )
	}

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

void function SURVIVAL_PlaceGroundItems()
{
	array<entity> itemEnts
	entity startLootEnt = Entities_FindByClassname( null, "script_ref" )

	while( IsValid( startLootEnt ) )
	{
		itemEnts.append( startLootEnt )
		startLootEnt = Entities_FindByClassname( startLootEnt, "script_ref" )
	}

	if ( GetCurrentPlaylistVarBool( "ground_loot_enable", true ) )
		foreach( ent in itemEnts )
		{
			if( GetEditorClass( ent ) != "info_survival_weapon_location" )
				continue

			OnGroundLootSpawned( ent )
		}

	FlagSet( "Survival_LootSpawned" )
}

string function LootZones_GetRefForOrigin(vector origin)
{
	FlagWait("Survival_LootZonesLoaded")

	if(Distance2D(file.hotZone.origin, origin) <= file.hotZone.radius)
		return "zone_hotzone"

	foreach(LootZone lz in file.lootZones)
	{
		if(Distance2D(lz.origin, origin) <= lz.radius)
			return lz.ref
	}

	return "zone_low" //fallback spawn low loot
}

vector function LootZones_GetParentForOrigin(vector origin)
{
	FlagWait("Survival_LootZonesLoaded")

	foreach(LootZone lz in file.lootZones)
	{
		if(Distance2D(lz.origin, origin) <= lz.radius)
		{
			return lz.origin
		}
	}
	return <0, 0, 0>
}

void function OnGroundLootSpawned( entity ent )
{
	string zoneRef = LootZones_GetRefForOrigin( ent.GetOrigin() )
	string itemRef

	string instance = ""
	if ( ent.HasKey( "instance_name" ) )
		instance = expect string( ent.kv.instance_name )
	
	vector origin = ent.GetOrigin()

	//save edicts
	if( IsValid( ent ) )
		ent.Destroy()

	bool isHoverTankLoot = instance == "HoverTank_1" || instance == "HoverTank_2"

	if(zoneRef == "data_knife_vault")
	{
		vector zoneOrigin = LootZones_GetParentForOrigin( origin )
		array<string> alreadySpawnedLoot
		if(zoneOrigin in file.vaultLootSpawned)
			alreadySpawnedLoot = file.vaultLootSpawned[zoneOrigin]
		else
			file.vaultLootSpawned[zoneOrigin] <- alreadySpawnedLoot
		itemRef = SURVIVAL_GetWeightedItemFromGroup( zoneRef )
		while(alreadySpawnedLoot.contains(itemRef))
		{
			itemRef = SURVIVAL_GetWeightedItemFromGroup( zoneRef )
		}
		//printt("Added item to Loot Vault: ", itemRef)
		alreadySpawnedLoot.push(itemRef)
	}
	else
	{
		itemRef = SURVIVAL_GetWeightedItemFromGroup( zoneRef )
	}

	if(itemRef == "blank" || itemRef == "mp_weapon_raygun")
		return

	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( itemRef )
	LootTypeData lt = GetLootTypeData( itemData.lootType)

	vector spawnOrigin = OriginToGround( origin )

	spawnOrigin.z += 1.5

	if( itemRef == "armor_pickup_lv5" || itemRef == "armor_pickup_lv6" || itemRef == "armor_pickup_lv7" )
		itemRef = "armor_pickup_lv3"

	if( GetCurrentPlaylistVarBool( "flowstate_evo_shields", false ) )
	{
		if( itemRef == "armor_pickup_lv2" || itemRef == "armor_pickup_lv3" || itemRef == "armor_pickup_lv4" || itemRef == "armor_pickup_lv5" || itemRef == "armor_pickup_lv6" || itemRef == "armor_pickup_lv7" )
			itemRef = "armor_pickup_lv1"
	}
	
	if(lt.specialCaseSpawnFunction != null)
	{
		lt.specialCaseSpawnFunction(itemRef, spawnOrigin)
		return
	}

	int angleZ = 0

	entity loot = SpawnGenericLoot( itemRef, spawnOrigin, <0, RandomFloatRange( -180, 180 ), angleZ>, itemData.countPerDrop )
	
	if( isHoverTankLoot )
	{
		// printt("detected hovertank loot" )
		entity parentPoint = CreateEntity( "script_mover_lightweight" )
		{
			parentPoint.kv.solid = 0
			parentPoint.SetValueForModelKey( $"mdl/dev/editor_ref.rmdl" )
			parentPoint.kv.SpawnAsPhysicsMover = 0
			parentPoint.SetOrigin( loot.GetOrigin() )
			parentPoint.SetAngles( loot.GetAngles() )
			DispatchSpawn( parentPoint )
			parentPoint.Hide()
			loot.SetParent(parentPoint)
			//parentPoint.SetParent( GetHoverTankByInstance( instance ) )
		}
	}
}

array<string> function GetRandomLootArray( int min, int max = -1 )
{
	array<string> items

	for( int i=0; i < RandomIntRange( min, max ); i++ )
	{
		items.append( GetRandomLootItem() )
	}

	return items
}

/*string function GetRandomLootItem()
{
	int numRows = GetDatatableRowCount( file.lootDataTable )

	int i = RandomInt( numRows )

	string itemRef = GetDataTableString( file.lootDataTable, i , GetDataTableColumnByName( file.lootDataTable, "ref" ) )
	string featureFlagRef = GetDataTableString( file.lootDataTable, i, GetDataTableColumnByName( file.lootDataTable, "featureFlag" ) )

	if ( itemRef == "blank"
		|| ( featureFlagRef != "" && !GetFeatureFlagByString( featureFlagRef ) )
		|| !LootTypeHasAnyChanceToSpawn( itemRef ) )
	{
		return GetRandomLootItem()
	}

	return itemRef
}*/

table< int, array<string> > possibleItemsForTiers = {}

array<string> function GetItemsOfTierOrGreater( int minTier )
{
	if ( !( minTier in possibleItemsForTiers ) )
	{
		possibleItemsForTiers[minTier] <- []

		foreach ( string lootRef, LootData lootData in SURVIVAL_Loot_GetLootDataTable() )
		{
			if ( !LootTypeHasAnyChanceToSpawn( lootRef ) )
				continue

			if ( minTier == eLootTier.LEGENDARY
				&& lootData.lootType == eLootType.MAINWEAPON )
				continue

			if ( lootData.tier >= minTier )
				possibleItemsForTiers[minTier].append( lootRef )
		}
	}

	return possibleItemsForTiers[minTier]
}

string function GetRandomLootItem( int mapZone = -1 )
{
	int minLootTier = -1
	int maxLootTier = ( mapZone != -1 ) ? MapZones_GetTierForZone( mapZone ) : eLootTier.LEGENDARY

	if ( maxLootTier == eLootTier.NONE )
		maxLootTier = eLootTier.COMMON // TEMP, I don't actually know how it works in retail

	if ( mapZone != -1 && maxLootTier > eLootTier.EPIC )
		minLootTier = maxLootTier

	// printt(FUNC_NAME(), "call", mapZone, minLootTier, maxLootTier)

	if ( minLootTier > -1 )
	{
		// We HAVE to find a loot of this min tier, so anything goes.
		array<string> possibleItems = GetItemsOfTierOrGreater( minLootTier )
		return possibleItems.getrandom()
	}
	else
	{
		int randomSelectedLootType = RandomIntRange( MIN_LOOT_TIER, MAX_LOOT_TIER )
		if ( randomSelectedLootType == eLootType.DATAKNIFE )
			randomSelectedLootType = eLootType.AMMO

		array<LootData> items = SURVIVAL_Loot_GetByType_InLevel( randomSelectedLootType, maxLootTier )

		if ( items.len() == 0 ) { // Tough luck, let's try again and hope this doesn't get into a recursion loop...
			printt( FUNC_NAME(), "No items! BUG THIS IF HAPPENS MORE THAN ONCE!", mapZone, minLootTier, maxLootTier, randomSelectedLootType )
			return GetRandomLootItem( mapZone )
		}

		return items.getrandom().ref
	}

	unreachable
}

bool function ClientCommand_Sur_DropEquipment( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_drop_equipment", true ) )
		return true

	if ( !IsValid( player ) )
		return true

	if ( args.len() < 1 )
		return true

	string slotRef = args[0]

	if ( !EquipmentSlot_IsValidEquipmentSlot( slotRef ) )
		return true

	EquipmentSlot es = Survival_GetEquipmentSlotDataByRef( slotRef )

	if ( es.weaponSlot != -1 )
	{
		vector origin = GetThrowOrigin( player )
		vector fwd    = AnglesToForward( player.EyeAngles() )

		int currentSlot = SURVIVAL_GetActiveWeaponSlot( player )

		if ( !SURVIVAL_DropMainWeapon( player, slotRef, origin, fwd ) )
			return true

		if ( currentSlot == es.weaponSlot )
		{
			string otherWeaponEsString = EquipmentSlot_GetOtherWeaponSlot( slotRef )
			EquipmentSlot otherWeaponEs = Survival_GetEquipmentSlotDataByRef( otherWeaponEsString )
			LootData otherWeaponData = EquipmentSlot_GetEquippedLootDataForSlot( player, otherWeaponEsString )

			player.SetActiveWeaponBySlot(
				eActiveInventorySlot.mainHand,
				otherWeaponData.ref != ""
					? otherWeaponEs.weaponSlot // Other weapon exists, switch to it
					: WEAPON_INVENTORY_SLOT_PRIMARY_2 // No other weapon, switch to melee instead
			)
		}
	}
	else
	{
		LootData itemData = EquipmentSlot_GetEquippedLootDataForSlot( player, slotRef )

		if ( itemData.ref == "" )
			return true

		entity spawnedItem = PlayerThrowLoot( player, itemData.ref )

		if ( itemData.lootType == eLootType.ARMOR )
		{
			spawnedItem.SetSurvivalProperty( player.GetShieldHealth() )
			spawnedItem.e.extraSurvivalProperty = player.GetShieldHealthMax()
			
			if( itemData.ref == "armor_pickup_lv7" )
				foreach ( sPlayer in GetPlayerArray() )
					Remote_CallFunction_NonReplay( sPlayer, "Flowstate_UpdateRainbowShieldExtraProperty", spawnedItem.GetEncodedEHandle(), spawnedItem.e.extraSurvivalProperty )
		}

		Inventory_SetPlayerEquipment( player, "", slotRef )

		if ( itemData.lootType == eLootType.BACKPACK )
		{
			spawnedItem.e.lootToAttachToBackpack = Flowstate_GetLootToRemoveFromBackpackLimit( player )
		}
	}

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}
 
array<string> function Flowstate_GetLootToRemoveFromBackpackLimit( entity player )
{
	array<string> lootToRemove

	int limit = SURVIVAL_GetInventoryLimit( player )
	array<ConsumableInventoryItem> playerInventory = player.ConsumableInventory_Get()
	int backPackCount = playerInventory.len()

	if ( backPackCount > limit )
	{
		for ( int i=backPackCount-1; i>=limit; i-- )
		{
			ConsumableInventoryItem invItem = playerInventory[i]
			LootData data = SURVIVAL_Loot_GetLootDataByIndex( invItem.type )
			lootToRemove.append( data.ref )
			printt( "adding item to backpack for posterior drop: " + data.ref )
		}
	}
	
	return lootToRemove
}

bool function ClientCommand_Sur_DropBackpackItem( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_drop_item", true ) )
		return true
	
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 2 )
		return true

	string itemRef = args[0]
	int count = int( args[1] )
	entity deathBox = null

	if ( args.len() > 2 )
		deathBox = GetEntityFromEncodedEHandle( int( args[2] ) )

	// if ( deathBox != null )
	// {
		// printt( FUNC_NAME(), "deathBox not null! TODO" )
	// }
	// else
	// {
		if ( count > SURVIVAL_CountItemsInInventory( player, itemRef ) )
			return true

		SURVIVAL_DropBackpackItem( player, itemRef, count )
	// }

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_Sur_EquipAttachment( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_equip_attachment", true ) )
		return true

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 1 )
		return true

	string ref = args[0]
	entity weapon = null

	if ( args.len() > 1 )
	{
		int weaponSlot = int( args[1] )

		if ( weaponSlot != WEAPON_INVENTORY_SLOT_PRIMARY_0
			&& weaponSlot != WEAPON_INVENTORY_SLOT_PRIMARY_1 )
			return true

		weapon = player.GetNormalWeapon( weaponSlot )

		if ( !IsValid( weapon ) )
			return true
	}

	if ( !SURVIVAL_Loot_IsRefValid( ref ) )
		return true

	if ( SURVIVAL_CountItemsInInventory( player, ref ) < 1 )
		return true

	if ( weapon == null )
	{
		array<entity> weapons = SURVIVAL_GetPrimaryWeaponsSorted( player )
		foreach ( weaponCandidate in weapons )
		{
			if ( CanAttachToWeapon( ref, GetWeaponClassName( weaponCandidate ) ) )
			{
				weapon = weaponCandidate
				break
			}
		}

		if ( weapon == null ) // Still null?
			return true // No suitable weapons for attachment
	}

	string modToRemove = SURVIVAL_GetModToRemoveForAttachment( player, weapon, ref )
	
	printt( "Mod to remove is bugged " + modToRemove )
	AttachToWeapon( player, weapon, ref, modToRemove, true, true, false, false, null, true, true )

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_Sur_UnequipAttachment( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_unequip_attachment", true ) )
		return true

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 3 )
		return true

	string ref = args[0]
	int weaponSlot = int( args[1] )
	bool removeToGround = args[2] == "true"

	if ( weaponSlot != WEAPON_INVENTORY_SLOT_PRIMARY_0
		&& weaponSlot != WEAPON_INVENTORY_SLOT_PRIMARY_1 )
		return true

	if ( !SURVIVAL_Loot_IsRefValid( ref ) )
		return true

	entity weapon = player.GetNormalWeapon( weaponSlot )

	if ( !IsValid( weapon ) )
		return true

	array<string> weaponMods = weapon.GetMods()

	if ( weapon.IsDiscarding() )
		return false

	if ( !weaponMods.contains( ref ) )
		return true

	EquipAttachments_Internal( player, weapon, "", ref, false, !removeToGround, false, false, null )

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_Sur_TransferAttachment( entity player, array<string> args )
{
	if ( !GetCurrentPlaylistVarBool( "survival_transfer_attachment", true ) )
		return true

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 2 )
		return true

	string ref = args[0]
	int weaponFromSlot = int( args[1] )

	if ( weaponFromSlot != WEAPON_INVENTORY_SLOT_PRIMARY_0
		&& weaponFromSlot != WEAPON_INVENTORY_SLOT_PRIMARY_1 )
		return true

	if ( !SURVIVAL_Loot_IsRefValid( ref ) )
		return true

	entity weaponFrom = player.GetNormalWeapon( weaponFromSlot )

	if ( !IsValid( weaponFrom ) )
		return true

	array<string> weaponFromMods = weaponFrom.GetMods()
	LootData weaponFromLootData = SURVIVAL_GetLootDataFromWeapon( weaponFrom )

	int weaponToSlot =
		weaponFromSlot == WEAPON_INVENTORY_SLOT_PRIMARY_0
			? WEAPON_INVENTORY_SLOT_PRIMARY_1
			: WEAPON_INVENTORY_SLOT_PRIMARY_0
	entity weaponTo = player.GetNormalWeapon( weaponToSlot )

	if ( !IsValid( weaponTo ) )
		return true

	array<string> weaponToMods = weaponTo.GetMods()
	LootData weaponToLootData = SURVIVAL_GetLootDataFromWeapon( weaponTo )

	if ( !weaponFromMods.contains( ref ) || weaponToMods.contains( ref ) )
		return true

	if ( !CanAttachToWeapon( ref, GetWeaponClassName( weaponTo ) ) )
		return true // Unsupported attachment
	
	string refAttachPointOg = GetAttachPointForAttachmentOnWeapon( weaponFrom.GetWeaponClassName(), ref )
	
	if ( refAttachPointOg != "sight" && weaponFromLootData.baseMods.contains( ref ) )
		return true // A default non-removable attachment

	string refAttachPoint = GetAttachPointForAttachmentOnWeapon( weaponTo.GetWeaponClassName(), ref )
	string toAttachPointAttachmentRef = GetInstalledWeaponAttachmentForPoint( weaponTo, refAttachPoint )

	if ( toAttachPointAttachmentRef != "" )
	{
		if ( refAttachPoint != "sight" && weaponToLootData.baseMods.contains( toAttachPointAttachmentRef ) )
			return true // Can't swap default attachments

		weaponTo.RemoveMod( toAttachPointAttachmentRef )
	}

	weaponFrom.RemoveMod( ref )
	
	try {
		weaponTo.AddMod( ref )
	}
	catch( e420 ) {
		printt( "Invalid mod. - ", ref )
		weaponTo.RemoveMod( ref )
	}

	if ( toAttachPointAttachmentRef != "" )
	{
		if ( !CanAttachToWeapon( toAttachPointAttachmentRef, GetWeaponClassName( weaponFrom ) ) )
		{
			// Install in backpack. Not enough space? Throw to ground. Colombia
			bool isInventoryFull = SURVIVAL_AddToPlayerInventory( player, toAttachPointAttachmentRef, 1 ) == 0
			if ( isInventoryFull )
				PlayerThrowLoot( player, toAttachPointAttachmentRef )
		} else
		{
			try {
				weaponFrom.AddMod( toAttachPointAttachmentRef )
			}
			catch( e421 ) {
				printt( "Invalid mod. - ", toAttachPointAttachmentRef )
				weaponFrom.RemoveMod( toAttachPointAttachmentRef )
			}
		}
	}
	
	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	EmitSoundOnEntityOnlyToPlayer( player, player, "survival_loot_attach_pas_fast_swap" )

	return true
}

bool function ClientCommand_Sur_SwapPrimaryPositions( entity player, array<string> args )
{
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( player.IsWeaponChangeLocked() )
		return true

	// This is horrendous.

	int activeSlot = SURVIVAL_GetActiveWeaponSlot( player )

	entity weapon0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	string weapon0ClassName = IsValid( weapon0 ) ? GetWeaponClassName( weapon0 ) : ""
	int weapon0Ammo =  ( IsValid( weapon0 ) && weapon0.UsesClipsForAmmo() ) ? weapon0.GetWeaponPrimaryClipCount() : 0
	array<string> ornull weapon0Mods = IsValid( weapon0 ) ? weapon0.GetMods() : null

	entity weapon1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )
	string weapon1ClassName =  IsValid( weapon1 ) ? GetWeaponClassName( weapon1 ) : ""
	int weapon1Ammo =  ( IsValid( weapon1 ) && weapon1.UsesClipsForAmmo() ) ? weapon1.GetWeaponPrimaryClipCount() : 0
	array<string> ornull weapon1Mods = IsValid( weapon1 ) ? weapon1.GetMods() : null

	if ( IsValid( weapon0 ) )
		player.TakeNormalWeaponByIndexNow( WEAPON_INVENTORY_SLOT_PRIMARY_0 )

	if ( IsValid( weapon1 ) )
		player.TakeNormalWeaponByIndexNow( WEAPON_INVENTORY_SLOT_PRIMARY_1 )

	if ( weapon0ClassName != "" )
	{
		expect array<string>( weapon0Mods )

		entity newWeapon1 = null

		if ( activeSlot == 0 )
			newWeapon1 = player.GiveWeapon( weapon0ClassName, WEAPON_INVENTORY_SLOT_PRIMARY_1, weapon0Mods, false )
		else
			newWeapon1 = player.GiveWeapon_NoDeploy( weapon0ClassName, WEAPON_INVENTORY_SLOT_PRIMARY_1, weapon0Mods, false )

		if ( IsValid( newWeapon1 ) && weapon0Ammo > 0 )
			newWeapon1.SetWeaponPrimaryClipCount( weapon0Ammo )
	}

	if ( weapon1ClassName != "" )
	{
		expect array<string>( weapon1Mods )

		entity newWeapon0 = null

		if ( activeSlot == 1 )
			newWeapon0 = player.GiveWeapon( weapon1ClassName, WEAPON_INVENTORY_SLOT_PRIMARY_0, weapon1Mods, false )
		else
			newWeapon0 = player.GiveWeapon_NoDeploy( weapon1ClassName, WEAPON_INVENTORY_SLOT_PRIMARY_0, weapon1Mods, false )

		if ( IsValid( newWeapon0 ) && weapon1Ammo > 0 )
			newWeapon0.SetWeaponPrimaryClipCount( weapon1Ammo )
	}
	player.ClearFirstDeployForAllWeapons()
	Remote_CallFunction_NonReplay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_PlayerSwitchedWeapons( entity player, array<string> args )
{
	if ( player.PlayerMelee_IsAttackActive() )
		return false

	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	if ( args.len() < 1 )
		return true

	int slot = int( args[0] )

	if ( slot != WEAPON_INVENTORY_SLOT_PRIMARY_0
		&& slot != WEAPON_INVENTORY_SLOT_PRIMARY_1
		&& slot != WEAPON_INVENTORY_SLOT_PRIMARY_2 )
		return true

	if ( player.IsWeaponChangeLocked() )
		return true

	player.SetActiveWeaponBySlot( eActiveInventorySlot.mainHand, slot )

	Remote_CallFunction_Replay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return true
}

bool function ClientCommand_BackpackOpened( entity player, array<string> args )
{
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	player.SetInventoryIsOpen()

	return true
}

bool function ClientCommand_BackpackClosed( entity player, array<string> args )
{
	if ( !IsValid( player ) || !IsAlive( player ) )
		return true

	player.ClearInventoryIsOpen()

	return true
}

bool function LootTypeHasAnyChanceToSpawn( string ref )
{
	if ( ref == "blank" )
		return false

	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( ref )

	if ( itemData.lootType == eLootType.DATAKNIFE )
		return false // DATAKNIFE - Vault Key

	return true
}

void function SpawnLoot( string name, vector origin, bool idk )
{
	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( name )
	SURVIVAL_ThrowLootFromPoint( origin, <0, 0, 0>, name, itemData.countPerDrop )
}

void function SURVIVAL_ThrowLootFromPoint( vector throwOrigin, vector forward, string ref, int count )
{
	entity loot = SpawnGenericLoot( ref, throwOrigin, <0, 0, 0>, count )
	FakePhysicsThrow( null, loot, forward * 100 )
}

void function SURVIVAL_PlayerPickedupItem( entity pickup, entity player, int action, int pickupFlags, bool shouldKeepAlive = false )
{
	//SURVIVAL_PlayerPickedupItem( pickup, player, as.action, pickupFlags, !shouldDestroy )
	//printt("!!! SURVIVAL_PlayerPickedupItem !!!")
	LootData pickupData = SURVIVAL_Loot_GetLootDataByIndex( pickup.GetSurvivalInt() )
	BroadcastItemPickup( player, pickupData.ref, action )

	pickup.Signal( "OnItemPickup", { player = player } )

	// if( pickupData.ref == "snd_bomb" && GameRules_GetGameMode() == "flowstate_snd" && GetGameState() == eGameState.Playing )
	// {
		// player.p.playerHasBomb = true
		// SetBombState(bombState.CARRIED)
		// SetBombEntity(null)
		
		// printt("new bomb carrier " + player + player.p.playerHasBomb)
		
		// thread SND_ThreadThatChecksIfPlayerDisconnects(player)
		
		// foreach(sPlayer in GetPlayerArrayOfTeam( Sh_GetAttackerTeam() ))
		// {
			// if(!IsValid(sPlayer)) continue
			
			// Remote_CallFunction_NonReplay( sPlayer, "SND_HintCatalog_WithEntity", 0, player) //a player have the bomb
		// }
	// }
	
	if( pickupData.ref == "fs_ball" && GetGameState() == eGameState.Playing )
	{
		// player.p.playerHasBomb = true
		SetBallEntity( null )
		SetBallCarrier( player )

		printt("New ball carrier " + player)

		//thread SND_ThreadThatChecksIfPlayerDisconnects(player)

		// foreach(sPlayer in GetPlayerArrayOfTeam( Sh_GetAttackerTeam() ))
		// {
			// if(!IsValid(sPlayer)) continue
			
			// Remote_CallFunction_NonReplay( sPlayer, "SND_HintCatalog_WithEntity", 0, player) //a player have the bomb
		// }
	}
	if (!shouldKeepAlive)
	{
		pickup.Destroy()
	}
}

entity function PlayerThrowLoot( entity player, string ref, vector angles = <0, 0, 0>, int count = 1, bool fromBackpackLimit = false )
{
	vector origin = GetThrowOrigin( player )
	vector fwd    = ( AnglesToForward( player.EyeAngles() ) * RandomIntRange( 80, 300) ) + ( AnglesToRight( player.EyeAngles() ) * RandomInt( 250 ) ) // This is ass Please fix. Colombia

	if( CoinFlip() )
		fwd    = ( AnglesToForward( player.EyeAngles() ) * RandomIntRange( 80, 300 ) ) - ( AnglesToRight( player.EyeAngles() ) * RandomInt( 250 ) ) // This is ass Please fix. Colombia

	entity loot
	
	if( ref == "snd_bomb" )
	{
		printt("bomb dropped by " + player)
		// player.p.playerHasBomb = false
		// Signal(player, "ForceEndBombCheckThread")
		
		// if(IsValid(GetBombEntity())) 
			// GetBombEntity().Destroy()
		
		// loot = SpawnGenericLoot( ref, origin, angles, count )
		
		// SetBombEntity(loot)

		// SetBombState(bombState.ONGROUND_IDLE)
		// loot.SetOrigin(player.GetOrigin())
		
		// foreach( sPlayer in GetPlayerArrayOfTeam(Sh_GetAttackerTeam()) )
		// {
			// if(!IsValid(sPlayer)) continue
			
			// Remote_CallFunction_NonReplay( sPlayer, "SND_HintCatalog_WithEntity", 2, player) //a player dropped the bomb
		// }
	} else if( ref == "fs_ball" )
	{
		printt("Ball dropped by " + player)

		if( IsValid( GetBallEntity() ) ) 
			GetBallEntity().Destroy()

		ClearBallCarrierPlayerSetup( player )
		
		loot = SpawnGenericLoot( ref, origin, angles, count )
		SetBallEntity( loot )
		// loot.SetOrigin( player.GetOrigin() )
	}
	else
		loot = SpawnGenericLoot( ref, origin, angles, count )

	SetItemSpawnSource( loot, eSpawnSource.PLAYER_DROP, player )
	
	if( !fromBackpackLimit )
		FakePhysicsThrow( player, loot, fwd )
	else
		FakePhysicsThrow( player, loot, AnglesToForward( player.EyeAngles() ) * RandomIntRange( 100, 300 ) ) // This is just a workaround for items from backpack limit check dropping in same pos as backpack and not allowing to grab backpack. In retail, the items are attached to the backpack and spawned in a circle when the backpack reaches the ground, fix this
	
	BroadcastItemDrop( player, ref )
	
	thread function() : ( player, loot )
	{
		EndSignal( loot, "EndTyThread" )
		
		thread TimeOutThanksPromptForThrowedLoot( loot )
		
		entity pickedUpBy = expect entity( loot.WaitSignal( "OnItemPickup" ).player )

		if ( !IsValid( pickedUpBy ) || player == pickedUpBy || pickedUpBy.GetTeam() != player.GetTeam() )
			return

		Remote_CallFunction_NonReplay( pickedUpBy, "ServerCallback_PromptSayThanks", player )
	}()
	
	return loot
}

void function TimeOutThanksPromptForThrowedLoot( entity loot )
{
	EndSignal( loot, "OnDestroy" )

	OnThreadEnd(
		function() : ( loot )
		{
			if( IsValid( loot ) )
				Signal( loot, "EndTyThread" )
		}
	)
	
	float endtime = Time() + 60
	
	while( Time() < endtime )
		wait 1
}

void function EquipAttachments_Internal( entity player, entity weapon, string item, string modToRemove, bool takeFromInventory, bool returnToInventory, bool forceActive, bool attachRemovedModToStowedIfBetter, entity deathBox )
{
	#if DEVELOPER
	printt("start EquipAttachments_Internal", player, weapon, item, modToRemove, takeFromInventory, returnToInventory, forceActive, attachRemovedModToStowedIfBetter, deathBox)
	#endif
	
	if( !IsValid( player ) || !IsValid( weapon ) )
		return

	if ( takeFromInventory && item != "" )
		if ( IsValid( deathBox ) )
		{
			foreach ( deathBoxItem in deathBox.GetLinkEntArray() )
			{
				if ( deathBoxItem.e.lootRef == item )
				{
					deathBoxItem.Destroy()
					break
				}
			}
		}
		else
			SURVIVAL_RemoveFromPlayerInventory( player, item, 1 )

	array<string> mods = clone weapon.GetMods()

	if ( modToRemove != "" && mods.contains( modToRemove ) )
	{
		// #if DEVELOPER
		// printt("removing mod in weapon: " + weapon, modToRemove )
		// #endif
		weapon.RemoveMod( modToRemove )
		mods.fastremovebyvalue( modToRemove )
		VerifyToggleMods( mods )

		int stowedWeaponSlot = SURVIVAL_GetStowedWeaponSlot( player )
		entity stowedWeaponEnt = player.GetNormalWeapon( stowedWeaponSlot )
		// #if DEVELOPER
		// printt( "STOWED WEAPON ENT: " + stowedWeaponEnt )
		// #endif
		LootData modToRemoveData = SURVIVAL_Loot_GetLootDataByRef( modToRemove )
		
		//By @CafeFPS
		if ( attachRemovedModToStowedIfBetter && IsValid( stowedWeaponEnt ) && stowedWeaponEnt != weapon && !stowedWeaponEnt.IsDiscarding() && !stowedWeaponEnt.IsWeaponOffhand() && CanAttachToWeapon( modToRemoveData.ref, stowedWeaponEnt.GetWeaponClassName() ) && IsAttachmentAnUpgrade( player, modToRemoveData, eLootAction.ATTACH_TO_STOWED ) )
		{
			// #if DEVELOPER
			// printt( "entering first debug Attachments zone ")
			// #endif
			string attachPoint = GetAttachPointForAttachmentOnWeapon( GetWeaponClassNameWithLockedSet( stowedWeaponEnt ), modToRemoveData.ref )
			string installed = GetInstalledWeaponAttachmentForPoint( stowedWeaponEnt, attachPoint )
			LootData attachedData

			// revisar si hay un attachment en el puesto donde va a estar modToRemove ( que en este caso es el mod a agregar )
			if ( SURVIVAL_Loot_IsRefValid( installed ) )
			{
				attachedData = SURVIVAL_Loot_GetLootDataByRef( installed )
				stowedWeaponEnt.RemoveMod( installed )
				if ( returnToInventory )
				{
					if ( IsValid( deathBox ) )
					{
						entity modLoot = SpawnGenericLoot( installed, deathBox.GetOrigin(), deathBox.GetAngles(), 1 )
						AddToDeathBox( modLoot, deathBox )
					}
					else
					{
						bool isInventoryFull = SURVIVAL_AddToPlayerInventory( player, installed, 1 ) == 0
						if ( isInventoryFull )
							PlayerThrowLoot( player, installed )
					}
				}
				else
					PlayerThrowLoot( player, installed )
			}

			try {
				stowedWeaponEnt.AddMod( modToRemove )
			}
			catch( e420 ) {
				printt( "DEBUG THIS - Failed to attach attachment on stowed weapon ", player.GetPlayerName(), "item", item, "modToRemove", modToRemove )
				printt( "Invalid mod. - ", modToRemove )
				stowedWeaponEnt.RemoveMod( modToRemove )
			}
			// #if DEVELOPER
			// foreach( weirdBug in stowedWeaponEnt.GetMods() )
				// printt( " DEBUGGING MODS ON STOWED WEAPON " + weirdBug )
			// #endif
		} else if ( returnToInventory )
		{
			// #if DEVELOPER
			// printt( "return to inventory debug part")
			// #endif
			if ( IsValid( deathBox ) )
			{
				entity modLoot = SpawnGenericLoot( modToRemove, deathBox.GetOrigin(), deathBox.GetAngles(), 1 )
				AddToDeathBox( modLoot, deathBox )
			}
			else
			{
				bool isInventoryFull = SURVIVAL_AddToPlayerInventory( player, modToRemove, 1 ) == 0
				if ( isInventoryFull )
					PlayerThrowLoot( player, modToRemove )
			}
		}
		else
		{
			// #if DEVELOPER
			// printt( "this should be at least executing debug")
			// #endif
			PlayerThrowLoot( player, modToRemove )
		}
	}

	if ( item != "" )
	{
		LootData weaponData = SURVIVAL_Loot_GetLootDataByRef( GetWeaponClassName( weapon ) )
		LootData modData = SURVIVAL_Loot_GetLootDataByRef( item )

		// only used for logging pickups to obituary, which is always disabled, so we can turn this off to save on the pain that is changing remote funcs.
		//Remote_CallFunction_NonReplay( player, "ServerCallback_AttachedMod", weaponData.index, modData.index )

		mods.append( item )
		VerifyToggleMods( mods )
		
		// #if DEVELOPER
		// foreach( weirdBug in weapon.GetMods() )
			// printt( " DEBUGGING MODS ON WEAPON " + weirdBug ) 
		// #endif

		try {
			weapon.AddMod( item )
		}
		catch( e420 ) {
			printt( "DEBUG THIS - Failed to attach attachment debug part 1", player.GetPlayerName(), "item", item, "modToRemove", modToRemove )
			printt( "Invalid mod. - ", item )
			weapon.RemoveMod( item )
		}
		PlayPickupSound( player, item )
	}

	int slot = -1
	if ( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 ) == weapon )
		slot = 0
	else if ( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 ) == weapon )
		slot = 1

	if ( SURVIVAL_GetActiveWeaponSlot( player ) == slot || forceActive )
		player.SetActiveWeaponBySlot( eActiveInventorySlot.mainHand, slot )

	Remote_CallFunction_Replay( player, "ServerCallback_UpdateHudWeaponData", weapon )
	
	#if DEVELOPER
	printt("EquipAttachments_Internal", player.GetPlayerName(), "item", item, "modToRemove", modToRemove)
	#endif
}

void function PlayPickupSound( entity player, string ref, int pickupFlags = 0 )
{
	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( ref )
	EmitSoundOnEntityExceptToPlayer( player, player, itemData.pickupSound_3p )
}

void function AddRoundsToWeapon( entity player, entity weapon, int numRounds )
{
	if ( weapon.UsesClipsForAmmo() )
		weapon.SetWeaponPrimaryClipCount( int( min( weapon.GetWeaponPrimaryClipCount() + numRounds, weapon.GetWeaponPrimaryClipCountMax() ) ) )
	else {
		int ammoType = weapon.GetWeaponAmmoPoolType()

		player.AmmoPool_SetCapacity( 65535 )
		player.AmmoPool_SetCount( ammoType, player.AmmoPool_GetCount( ammoType ) + numRounds )
	}
}

void function Survival_SetInventoryEnabled( entity player, bool state )
{
	player.SetPlayerNetBool( "inventoryEnabled", state )
}

void function SURVIVAL_TryTakeDefaultMeleePrimary( entity player )
{

}

void function TrackingVision_CreatePOIForPickedUpLoot( entity player, int lootType, string ref, vector origin, int team, entity idk )
{

}

void function SURVIVAL_GiveMainWeapon( entity player, entity pickup, entity activeWeapon, bool dropCurrentWeapon, entity deathBox, bool doPickupPrint )
{
	if( !IsValid( player ) )
		return

	if( !IsValid( pickup ) )
		return

	if( !IsValid( activeWeapon ) )
		return

	if ( !IsWeaponInPrimarySlot( player, activeWeapon ) )
	{
		activeWeapon = SURVIVAL_GetLastActiveWeapon( player )
	}

	LootData newEquipData = SURVIVAL_Loot_GetLootDataByIndex( pickup.GetSurvivalInt() )
	LootTypeData lt       = GetLootTypeData( newEquipData.lootType )

	string newEquip     = newEquipData.ref

	LootData oldEquipData

	if ( IsValid( activeWeapon ) && SURVIVAL_Loot_IsRefValid( GetWeaponClassName( activeWeapon ) ) )
	{
		oldEquipData = SURVIVAL_GetLootDataFromWeapon( activeWeapon )
	}

	LootRef lootRef       = SURVIVAL_CreateLootRef( newEquipData, pickup )
	LootActionStruct as   = lt.groundActionFunc( player, lootRef )

	array<string> mods = clone newEquipData.baseMods
	entity weaponToDrop
	int weaponSlot = WEAPON_INVENTORY_SLOT_ANY

	if ( IsValid( activeWeapon ) && dropCurrentWeapon && oldEquipData.ref != "" )
	{
		array<string> activeMods = activeWeapon.GetMods()

		if ( !activeMods.contains( "gold" ) && !SURVIVAL_Weapon_IsAttachmentLocked( newEquip ) )
		{
			table<string, string> suitableAttachmentsFromWeapon = GetCompatibleAttachmentsFromWeapon( player, activeWeapon, newEquipData.baseWeapon )
			foreach ( wepPoint, wepMod in suitableAttachmentsFromWeapon )
			{
				bool skipThisAttachment = false

				foreach ( baseMod in mods )
				{
					if ( !SURVIVAL_Loot_IsRefValid( baseMod ) || !IsValidAttachment( baseMod ) )
						continue

					if ( GetAttachPointForAttachmentOnWeapon( oldEquipData.ref, baseMod ) == wepPoint )
					{
						skipThisAttachment = true
						break
					}
				}

				if ( skipThisAttachment )
					continue // There is already an installed attachment, don't install a second one
				
				try{
					if( activeWeapon.HasMod( wepMod ) )
						activeWeapon.RemoveMod( wepMod )
				}catch(e420)
				{
					
				}

				mods.append( wepMod )
			}
		}

		EquipmentSlot es = Survival_GetEquipmentSlotDataByRef( "main_weapon" + GetSlotForWeapon( player, activeWeapon ) )

		// Create tracking event for players with tracking passive.
		if ( es.trackingVisionExchangePOI != -1 )
			TrackingVision_CreatePOI( es.trackingVisionExchangePOI, player, pickup.GetOrigin(), player.GetTeam(), player )
		
		player.HolsterWeapon()

		if ( IsValid( deathBox ) )
		{
			weaponSlot = es.weaponSlot

			if ( weaponSlot == -1 )
				return

			weaponToDrop = player.GetNormalWeapon( weaponSlot )

			if ( !IsValid( weaponToDrop ) )
				return

			foreach ( loot in CreateEntitiesForDroppedWeaponAndAttachments( player, weaponToDrop, deathBox.GetOrigin() ) )
				AddToDeathBox( loot, deathBox )
		}
		else
		{
			vector origin = GetThrowOrigin( player )
			vector fwd    = AnglesToForward( player.EyeAngles() )

			if ( es.specialCaseDropFunc != null )
				es.specialCaseDropFunc( player, es.ref, origin, fwd )
			else
				SURVIVAL_DropMainWeapon( player, es.ref, origin, fwd )
		}
	}

	foreach ( possibleHopupMod in newEquipData.baseMods )
		ApplyDefaultToggledMods( newEquipData.baseWeapon, possibleHopupMod, mods )

	// Auto-pickup suitable attachments from inventory
	if ( !mods.contains( "gold" ) && !mods.contains( "crate" ) )
	{
		table<string, string> suitableAttachmentsFromInventory = GetCompatibleAttachmentsFromInventory( player, newEquipData.baseWeapon )
		foreach ( point, mod in suitableAttachmentsFromInventory )
		{
			bool skipThisAttachment = false

			foreach ( baseMod in mods )
			{
				if ( !SURVIVAL_Loot_IsRefValid( baseMod ) || !IsValidAttachment( baseMod ) )
					continue
				
				array<string> attachPoints = GetAttachPointsForAttachment( baseMod )

				if ( GetAttachmentPointName( attachPoints[0] ) == point )
				{
					skipThisAttachment = true
					break
				}
			}

			if ( skipThisAttachment )
				continue // There is already an installed attachment, don't install a second one

			SURVIVAL_RemoveFromPlayerInventory( player, mod, 1 )
			mods.append( mod )
		}
	}

	if( newEquipData.baseMods.contains( "gold" ) && pickup.e.crateWeaponCustomSight != "-1" || newEquipData.baseMods.contains( "crate" ) && pickup.e.crateWeaponCustomSight != "-1" )
	{
		// printt("adding " + pickup.e.crateWeaponCustomSight + " as base mod " )

		foreach( mod in mods )
		{
			if( IsValidAttachment( mod ) && GetAttachPointForAttachmentOnWeapon( newEquipData.baseWeapon, mod ) == "sight" )
			{
				mods.fastremovebyvalue( mod )
				mods.append( pickup.e.crateWeaponCustomSight )
			}
		}
	}

	thread function () : ( player, newEquipData, mods, pickup, dropCurrentWeapon, weaponSlot ) 
	{		
		int clipCount = pickup.GetClipCount()
		int lastAmmo = pickup.e.crateWeaponLastAmmo
		int lastClip = pickup.e.crateWeaponLastAmmoClip

		player.AmmoPool_SetCapacity( 65535 )

		entity weapon = player.GiveWeapon( newEquipData.baseWeapon, weaponSlot, mods, true )

		if( IsValid(weapon) && weapon.Anim_HasActivity( "ACT_VM_DRAW" ) )
		{
			weapon.OverrideNextAttackTime( Time() + weapon.GetSequenceDuration( "ACT_VM_DRAW" ) ) // This seems to avoid player to shoot instantly when in fast deploy bug (sprinting), will keep for now
		}
		player.DeployWeapon()
		player.SetActiveWeaponBySlot( eActiveInventorySlot.mainHand, GetSlotForWeapon( player, weapon ) )

		if(GameRules_GetGameMode() == "fs_duckhunt" && weapon.GetWeaponClassName() == "mp_weapon_sniper" )
			weapon.AddMod("duckhunt")
		
		int ammoType = weapon.GetWeaponAmmoPoolType()

		int maxClipSize = weapon.UsesClipsForAmmo() ? weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) : weapon.GetWeaponPrimaryAmmoCountMax( weapon.GetActiveAmmoSource() )
		int ammoToGive = ( clipCount == GIVE_FULL_AMMO_MARKER ) ? maxClipSize : int( min( clipCount, maxClipSize ) )

		if( newEquipData.baseMods.contains( "crate" ) )
		{
			if( lastAmmo != -1 )
				weapon.SetWeaponPrimaryAmmoCount( AMMOSOURCE_STOCKPILE, lastAmmo )
			else
				weapon.SetWeaponPrimaryAmmoCount( AMMOSOURCE_STOCKPILE, weapon.GetWeaponPrimaryAmmoCountMax( AMMOSOURCE_STOCKPILE ) )
			
			if( weapon.UsesClipsForAmmo() && lastClip != -1 )
			{
				weapon.SetWeaponPrimaryClipCount( lastClip )
			}
		} else if( weapon.UsesClipsForAmmo() )
			weapon.SetWeaponPrimaryClipCount( ammoToGive )

		if ( InfiniteAmmoEnabled() && weapon.UsesClipsForAmmo() )
		{
			string ammoRef = AmmoType_GetRefFromIndex( ammoType )
			int currentAmmo = weapon.GetWeaponPrimaryClipCount()
			int maxAmmo = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
			int requiredAmmo = maxAmmo - currentAmmo
			int ammoInInventory = SURVIVAL_CountItemsInInventory( player, ammoRef )

			player.AmmoPool_SetCount( ammoType, ammoInInventory + requiredAmmo + maxClipSize )
		}

		if ( GetCurrentPlaylistVarBool( "flowstate_giveskins_weapons", false ) )
			weapon.SetLegendaryModelIndex(RandomInt(4))

		if ( GetCurrentPlaylistVarBool( "flowstate_give_hiswattson_charm", false ) )
		{		
			int charmIndex = RandomInt( 2 )
			
			switch( charmIndex )
			{
				case 0:
					weapon.SetWeaponCharm( $"mdl/flowstate_custom/charm_hiswattson_white.rmdl", "CHARM")
					//weapon.SetWeaponCharm( $"mdl/flowstate_custom/charm_hiswattson_blue.rmdl", "CHARM")
				break
				case 1:
					weapon.SetWeaponCharm( $"mdl/flowstate_custom/charm_hiswattson.rmdl", "CHARM")
				break
			}
		}
		
		Remote_CallFunction_NonReplay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )
	}()

}

vector function GetThrowOrigin( entity player )
{
	return player.EyePosition() + player.GetForwardVector() * 12
}

bool function ShouldSpawnThisLoot( string entryRef ) 
{
	if( GetCurrentPlaylistVarBool( "flowstate_evo_shields", false ) )
	{
		switch( entryRef )
		{
			case "armor_pickup_lv2":
			case "armor_pickup_lv3":
			case "armor_pickup_lv4_all_fast":
			case "armor_pickup_lv5":
			case "armor_pickup_lv6":
			case "armor_pickup_lv7":
				return false
		}
	}
	
	return true
}

entity function SpawnGenericLoot( string ref, vector origin, vector angles, int count )
{
	LootData data = SURVIVAL_Loot_GetLootDataByRef( ref )

	entity loot = CreateEntity( "prop_survival" )
	loot.SetOrigin( origin )
	loot.SetAngles( angles )

	loot.NotSolid()
	loot.SetUsable()
	loot.SetFadeDistance( 20000 )
	loot.AddUsableValue( USABLE_CUSTOM_HINTS | USABLE_BY_OWNER | USABLE_BY_PILOTS | USABLE_BY_ENEMIES )
	loot.SetUsablePriority( USABLE_PRIORITY_HIGH )
	loot.e.spawnTime = Time()
	loot.e.lootRef = ref
	
	loot.SetClipCount( count )
	loot.SetSurvivalInt( data.index )

	if ( data.lootType == eLootType.RESOURCE && count != data.countPerDrop )
		count *= data.countPerDrop

	if ( data.lootType == eLootType.MAINWEAPON )
		loot.SetWeaponName( data.baseWeapon )

	loot.SetModel( data.model )
	loot.SetSkin( 0 )

	loot.kv.renderamt = 255
	loot.kv.rendercolor = "255 255 255"

	if ( data.skinOverride > 0 )
		loot.SetSkin( data.skinOverride )

	if ( count == data.countPerDrop )
	{
		if ( data.lootType == eLootType.MAINWEAPON )
			loot.SetClipCount( GIVE_FULL_AMMO_MARKER )

		if ( data.lootType == eLootType.ARMOR )
			loot.SetSurvivalProperty( SURVIVAL_GetArmorShieldCapacity( data.tier ) )
	}

	DispatchSpawn( loot )

	return loot
}

void function SetItemSpawnSource( entity drop, int spawnSource, entity owner )
{
	drop.e.spawnSource = spawnSource
	if ( spawnSource != eSpawnSource.PLAYER_DROP )
		drop.SetParent( owner )
}

void function AddToDeathBox( entity drop, entity deathBox )
{
	drop.Hide()
	drop.UnsetUsable()

	drop.SetOrigin( deathBox.GetOrigin() )
	drop.SetParent( deathBox )

	deathBox.LinkToEnt( drop )
}

entity function SURVIVAL_CreateDeathBox( entity player, bool hasCard )
{
	entity box = CreatePropDeathBox_NoDispatchSpawn( DEATH_BOX, player.GetOrigin(), <0, 45, 0>, 6 )
	box.kv.fadedist = 10000
	if ( hasCard )
		SetTargetName( box, DEATH_BOX_TARGETNAME )

	DispatchSpawn( box )

	box.RemoveFromAllRealms()
	box.AddToOtherEntitysRealms( player )

	box.Solid()

	box.SetUsable()
	box.SetUsableValue( USABLE_BY_ALL | USABLE_CUSTOM_HINTS )

	box.SetOwner( player )
	box.SetNetInt( "ownerEHI", player.GetEncodedEHandle() )
	box.AllowMantle()
	
	if ( hasCard )
	{
		box.SetNetBool( "overrideRUI", false )

		// box.SetCustomOwnerName( player.GetPlayerName() )

		// EHI playerEHI = ToEHI( player )

		// LoadoutEntry characterLoadoutEntry = Loadout_CharacterClass()
		// ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterLoadoutEntry )
		// box.SetNetInt( "characterIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( characterLoadoutEntry, character ) )

		// LoadoutEntry skinLoadoutEntry = Loadout_CharacterSkin( character )
		// ItemFlavor characterSkin = LoadoutSlot_GetItemFlavor( playerEHI, skinLoadoutEntry )
		// box.SetNetInt( "skinIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( skinLoadoutEntry, characterSkin ) )

		// LoadoutEntry frameLoadoutEntry = Loadout_GladiatorCardFrame( character )
		// ItemFlavor characterFrame = LoadoutSlot_GetItemFlavor( playerEHI, frameLoadoutEntry )
		// box.SetNetInt( "frameIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( frameLoadoutEntry, characterFrame ) )

		// LoadoutEntry stanceLoadoutEntry = Loadout_GladiatorCardStance( character )
		// ItemFlavor characterStance = LoadoutSlot_GetItemFlavor( playerEHI, stanceLoadoutEntry )
		// box.SetNetInt( "stanceIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( stanceLoadoutEntry, characterStance ) )

		// LoadoutEntry firstBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 0 )
		// ItemFlavor characterFirstBadge = LoadoutSlot_GetItemFlavor( playerEHI, firstBadgeLoadoutEntry )
		// box.SetNetInt( "firstBadgeIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( firstBadgeLoadoutEntry, characterFirstBadge ) )
		// box.SetNetInt( "firstBadgeDataInt", GetPlayerBadgeDataInteger( playerEHI, characterFirstBadge, 0, character ) )

		// LoadoutEntry secondBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 1 )
		// ItemFlavor characterSecondBadge = LoadoutSlot_GetItemFlavor( playerEHI, secondBadgeLoadoutEntry )
		// box.SetNetInt( "secondBadgeIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( secondBadgeLoadoutEntry, characterSecondBadge ) )
		// box.SetNetInt( "secondBadgeDataInt", GetPlayerBadgeDataInteger( playerEHI, characterSecondBadge, 1, character ) )

		// LoadoutEntry thirdBadgeLoadoutEntry = Loadout_GladiatorCardBadge( character, 2 )
		// ItemFlavor characterThirdBadge = LoadoutSlot_GetItemFlavor( playerEHI, thirdBadgeLoadoutEntry )
		// box.SetNetInt( "thirdBadgeIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( thirdBadgeLoadoutEntry, characterThirdBadge ) )
		// box.SetNetInt( "thirdBadgeDataInt", GetPlayerBadgeDataInteger( playerEHI, characterThirdBadge, 2, character ) )
	}

	if ( hasCard )
	{
		Highlight_SetNeutralHighlight( box, "sp_objective_entity" )
		Highlight_ClearNeutralHighlight( box )

		thread Flowstate_DeathboxPhysics( box, player.GetVelocity() )
	}

	return box
}

void function Flowstate_DeathboxPhysics( entity deathbox, vector playerVelocity)
{
	entity prop_physics = CreateEntity( "prop_physics" )
	prop_physics.SetValueForModelKey( $"mdl/props/death_box/death_box_01.rmdl" )
	prop_physics.kv.solid = 0
	prop_physics.kv.spawnflags = SF_PHYSPROP_DEBRIS
	prop_physics.kv.fadedist = -1
	prop_physics.kv.renderamt = 255
	prop_physics.kv.rendercolor = "255 255 255"
	prop_physics.kv.minhealthdmg = 9999
	prop_physics.kv.nodamageforces = 1
	prop_physics.kv.physdamagescale = 0.1
	prop_physics.kv.inertiaScale = 0.5
	prop_physics.SetOrigin( deathbox.GetOrigin() )
	prop_physics.SetAngles( deathbox.GetAngles() )
	DispatchSpawn( prop_physics )

	playerVelocity += deathbox.GetUpVector() * 300 // player velocity probably needs a limit, needs more testing, same for deathbox inertia scale. Seems to work fine for now
	deathbox.SetParent( prop_physics )
	prop_physics.Hide()
	prop_physics.NotSolid()
	prop_physics.SetVelocity( playerVelocity )
	
	thread Flowstate_CheckForPhysicsMemoryLeak( deathbox, prop_physics )
}

void function FakePhysicsThrow( entity player, entity drop, vector forward, float DestroyTimer = -1, bool isCargoBot = false )
{
	entity physics = CreatePropPhysics( drop.GetModelName(), drop.GetOrigin(), drop.GetAngles() )
	vector velocity = forward * 1000

	// physics.PhysicsSetFriction( 50 )
	// physics.PhysicsSetDamping( 50, 50 )

	if( isCargoBot )
		velocity = forward * RandomIntRange(100, 300)
	
	drop.SetParent( physics )

	physics.Hide()

	drop.NotSolid()
	physics.NotSolid()

	physics.SetVelocity( forward )

	// thread Flowstate_CheckForPhysicsMemoryLeak( drop, physics )
	// physics sometimes will stuck even if item seems to be static already

}

void function Flowstate_CheckForPhysicsMemoryLeak( entity drop, entity physics )
{
	EndSignal( drop, "OnDestroy" )
	EndSignal( physics, "OnDestroy" )

	OnThreadEnd(
		function() : ( drop, physics )
		{
			if ( !IsValid( drop ) && IsValid( physics ) )
				physics.Destroy()
		}
	)

	vector velVector = physics.GetVelocity()
	float vel = velVector.Length()
	float lastVel = vel
	float numTicksSameSpeed

	while( IsValid( physics ) && vel > 0 )
	{
		
		velVector = physics.GetVelocity()
		vel = velVector.Length()
		// printt( vel )

		if( vel == lastVel )
		{
			numTicksSameSpeed++
			
			if( numTicksSameSpeed >= 25 )
			{
				break
			}
		}
		else
			numTicksSameSpeed = 0

		lastVel = vel
		WaitFrame()
	}

	if ( IsValid( drop ) )
		drop.ClearParent()

	if ( IsValid( physics ) )
		physics.Destroy()
}

void function SURVIVAL_GivePlayerEquipment( entity player, string newEquip, int value, int extravalue = -1)
{
	// newEquip - ref
	// Inventory_SetPlayerEquipment( entity player, string itemRef, string equipmentSlot, int propertyValue = 0 )
	LootData data = SURVIVAL_Loot_GetLootDataByRef( newEquip )
	string slot = ""
	/*
	ARMOR
	INCAPSHIELD
	JUMPKIT
	ORDNANCE
	ATTACHMENT
	CUSTOMPICKUP
	BACKPACK
	HELMET
	*/

	//printt("SURVIVAL_GivePlayerEquipment", player, newEquip, value)

	switch (data.lootType) {
		case eLootType.BACKPACK:
			slot = "backpack"
			break
		case eLootType.ARMOR:
			slot = "armor"
			break
		case eLootType.HELMET:
			slot = "helmet"
			break
		case eLootType.INCAPSHIELD:
			slot = "incapshield"
			break
		default:
			return
		/*case eLootType.BACKPACK:
			slot = "backpack"
			break*/
	}

	Inventory_SetPlayerEquipment(player, newEquip, slot, value, extravalue)
}

entity function SpawnWeaponAndAmmo( string ref, vector origin )
{
	//printt( "SpawnWeaponAndAmmo", ref, origin )
	entity ent

	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( ref )
	string ammoType = itemData.ammoType
	
	array<vector> circlePositions
	
	for(int i = 0; i < 8; i++)
	{
		float r = float(i) / float( 8 ) * 2 * PI
		circlePositions.append( origin + RandomFloatRange( 35, 45 ) * <sin( r ), cos( r ), 0.0> )
	}
	
	circlePositions.randomize()
	
	//Add two ammo stacks per weapon
	if ( SURVIVAL_Loot_IsRefValid( ammoType ) )
	{
		itemData = SURVIVAL_Loot_GetLootDataByRef( ammoType )

		vector nextOrigin = circlePositions.getrandom()
		file.spawnedAmmoStacks.append( SpawnGenericLoot(ammoType, nextOrigin, <0, RandomFloatRange( -180, 180 ), 1>, itemData.countPerDrop ) )
		circlePositions.fastremovebyvalue( nextOrigin )

		nextOrigin = circlePositions.getrandom()
		file.spawnedAmmoStacks.append( SpawnGenericLoot(ammoType, nextOrigin, <0, RandomFloatRange( -180, 180 ), 1>, itemData.countPerDrop ) )
		circlePositions.fastremovebyvalue( nextOrigin )
		
		//This will add sometimes two, sometimes one ammo stack

		// foreach( ammo in file.spawnedAmmoStacks )
		// {
			// foreach( possiblePos in circlePositions )
			// {
				// if( Distance2D( ammo.GetOrigin(), possiblePos ) < 25 )
					// circlePositions.fastremovebyvalue( possiblePos )
			// }
		// }
	
		// if( circlePositions.len() == 0 )
		// {
			// ent = SpawnGenericLoot(ref, origin + <0, 0, 1>, <0, RandomFloatRange( -180, 180 ), 90>, 1)
			// return ent
		// }
		
		// vector nextOrigin = circlePositions.getrandom()
		
		// file.spawnedAmmoStacks.append( SpawnGenericLoot(ammoType, nextOrigin, <0, RandomFloatRange( -180, 180 ), 1>, itemData.countPerDrop ) )
		// circlePositions.fastremovebyvalue( nextOrigin )
		
		// if( circlePositions.len() == 0 )
		// {
			// ent = SpawnGenericLoot(ref, origin + <0, 0, 1>, <0, RandomFloatRange( -180, 180 ), 90>, 1)
			// return ent
		// }

		// if( CoinFlip() )
		// {
			// nextOrigin = circlePositions.getrandom()
			// file.spawnedAmmoStacks.append( SpawnGenericLoot(ammoType, nextOrigin, <0, RandomFloatRange( -180, 180 ), 1>, itemData.countPerDrop ) )
		// }
	}

	ent = SpawnGenericLoot(ref, origin + <0, 0, 1>, <0, RandomFloatRange( -180, 180 ), 90>, 1)
	return ent
}

entity function SpawnArmor( string ref, vector origin )
{
	return SpawnGenericLoot(ref, origin, <0, RandomFloatRange( -180, 180 ), 1>, 1)
}

entity function SpawnNothing( string ref, vector origin, vector angles )
{
	// printt( "SpawnNothing", ref, origin )
	return null
}

entity function SpawnAllOptics()
{
	// printt( "SpawnAllOptics_STUB" )
	return null
}

array<entity> function CreateEntitiesForDroppedWeaponAndAttachments( entity player, entity weaponToDrop, vector origin )
{
	LootData dropWeaponData = SURVIVAL_GetLootDataFromWeapon( weaponToDrop )

	entity droppedWeapon = SpawnGenericLoot( dropWeaponData.ref, origin, <0, 0, 90>, weaponToDrop.GetWeaponPrimaryClipCount() )

	if( dropWeaponData.baseMods.contains( "crate" ) )
	{
		droppedWeapon.e.crateWeaponLastAmmo = weaponToDrop.GetWeaponPrimaryAmmoCount( weaponToDrop.GetActiveAmmoSource() )
		droppedWeapon.e.crateWeaponLastAmmoClip = weaponToDrop.GetWeaponPrimaryClipCount()
	}
	
	if( dropWeaponData.baseMods.contains( "crate" ) || dropWeaponData.baseMods.contains( "gold" ) )
	{
		if( !dropWeaponData.baseMods.contains( GetInstalledWeaponAttachmentForPoint( weaponToDrop, "sight" ) ) )
			droppedWeapon.e.crateWeaponCustomSight = GetInstalledWeaponAttachmentForPoint( weaponToDrop, "sight" )
	}
	
	BroadcastItemDrop( player, dropWeaponData.ref )

	array<entity> lootToDrop = [ droppedWeapon ]
	
	if( !SURVIVAL_Weapon_IsAttachmentLocked( dropWeaponData.ref ) )
	{
		foreach ( esRef, mod in GetAllWeaponAttachments( weaponToDrop ) )
		{
			if ( !SURVIVAL_Loot_IsRefValid( mod ) )
				continue

			if ( dropWeaponData.baseMods.contains( mod ) ) // Don't throw separate mods of legendary weapons, they are bundled
				continue

			entity droppedAttachment = SpawnGenericLoot( mod, origin, <0, 0, 0>, 1 )
			lootToDrop.append( droppedAttachment )

			BroadcastItemDrop( player, mod )
		}
	}

	// player.TakeWeaponByEnt( weaponToDrop )
	// player.DropWeapon( weaponToDrop )
	player.TakeWeaponByEntNow( weaponToDrop )
	// weaponToDrop.Destroy()

	Remote_CallFunction_NonReplay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )

	return lootToDrop
}

void function SwitchingTestIdk( entity player )
{
	while( true )
	{
		printt( "switching debug 1: " + player.IsSwitching( WEAPON_INVENTORY_SLOT_PRIMARY_0 ) )
		printt( "switching debug 2: " + player.IsSwitching( WEAPON_INVENTORY_SLOT_PRIMARY_1 ) )
		printt( "-----" )
		WaitFrame()
	}
}

bool function SURVIVAL_DropMainWeapon( entity player, string slot, vector origin, vector velocity )
{
	// printt( "SURVIVAL_DropMainWeapon" )
	int weaponSlot = Survival_GetEquipmentSlotDataByRef( slot ).weaponSlot

	if ( weaponSlot == -1 )
		return false

	entity weaponToDrop = player.GetNormalWeapon( weaponSlot )

	if ( !IsValid( weaponToDrop ) )
		return false
	
	array<entity> lootToDrop = CreateEntitiesForDroppedWeaponAndAttachments( player, weaponToDrop, origin )

	foreach ( loot in lootToDrop )
	{
		SetItemSpawnSource( loot, eSpawnSource.PLAYER_DROP, player )
		FakePhysicsThrow( player, loot, velocity * 100 )
	}

	return true
}

void function SURVIVAL_DropBackpackItem( entity player, string ref, int count, bool fromBackpackLimit = false )
{
	LootData itemData = SURVIVAL_Loot_GetLootDataByRef( ref )

	SURVIVAL_RemoveFromPlayerInventory( player, ref, count )
	entity item = PlayerThrowLoot( player, ref, <0, 0, 0>, count, fromBackpackLimit )

	if ( itemData.lootType == eLootType.AMMO )
	{
		int ammoType = AmmoType_GetTypeFromRef( ref )
		player.AmmoPool_SetCapacity( 65535 )
		player.AmmoPool_SetCount( ammoType, int( max( 0, player.AmmoPool_GetCount( ammoType ) - count ) ) )
	}

	if ( itemData.lootType == eLootType.ORDNANCE )
	{
		entity heldOrdnance = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_ANTI_TITAN )
		if ( IsValid( heldOrdnance ) && heldOrdnance.GetWeaponClassName() == ref )
		{
			player.TakeWeaponByEntNow( heldOrdnance )
			string nextOrdnance = GetNextOrdnance( player, ref )
			if ( nextOrdnance != "" )
				SwitchPlayerToOrdnance( player, nextOrdnance )
		}
	}
	
	if( itemData.ref == "data_knife" )
	{
		bool mateHasAnotherKey = false
		foreach( mate in GetPlayerArrayOfTeam( player.GetTeam() ) )
		{
			if( mate == player ) continue
			
			if( VaultPanel_HasPlayerDataKnife( mate ) )
				mateHasAnotherKey= true
		}

		foreach( mate in GetPlayerArrayOfTeam( player.GetTeam() ) )
		{	
			if( !mateHasAnotherKey )
			{
				foreach( minimapObj in VaultPanel_GetAllMinimapObjs() )
					SetMinimapObjectVisibleToPlayer( mate, minimapObj, false )
					
				foreach( paneldata in GetAllVaultPanelsData() )
					if( paneldata.openByTeamNumber == player.GetTeam() && paneldata.panelState == ePanelState.UNLOCKED )
						SetMinimapObjectVisibleToPlayer( mate, paneldata.openMinimapObj, true )
			} else
			{
				foreach( minimapObj in VaultPanel_GetBestMinimapObjs() )
					SetMinimapObjectVisibleToPlayer( mate, minimapObj, true )
			}
		}	
		
	}
	
	Remote_CallFunction_NonReplay( player, "ServerCallback_RefreshInventoryAndWeaponInfo" )
}

void function Loot_AddCallback_OnPlayerLootPickup( void functionref( entity user, entity lootPickup, string ref, bool willDestroy ) callback )
{

}

int function SURVIVAL_NumItemsInInventory( entity player, string itemRef )
{
	return SURVIVAL_CountItemsInInventory( player, itemRef )
}

void function ResetPlayerInventory( entity player )
{
	// Normal and offhand weapons
	TakeAllWeapons( player )

	// Inventory
	SetPlayerInventory( player, [] )

	// Clear all equipment slots
	foreach ( slot, slotData in EquipmentSlot_GetAllEquipmentSlots() )
		Inventory_SetPlayerEquipment( player, "", slot )
}

LootZone function GetLootHotZone()
{
	FlagWait("Survival_LootZonesLoaded")
	return file.hotZone
}

array<LootZone> function GetAllLootZones()
{
	FlagWait("Survival_LootZonesLoaded")
	return file.lootZones
}

int function SURVIVAL_LootTierForLootGroup( int zoneClass )
{
	switch ( zoneClass )
	{
		case eLootZoneClass.ZONE_LOW:
			return eLootTier.COMMON
		case eLootZoneClass.ZONE_MEDIUM:
			return eLootTier.RARE
		case eLootZoneClass.ZONE_HIGH:
		case eLootZoneClass.ZONE_HOTZONE:
			return eLootTier.EPIC
		case eLootZoneClass.ZONE_LOOT_VAULT:
			return eLootTier.LEGENDARY
		default:
			return eLootTier.NONE
	}

	unreachable
}

bool function IsWeaponInPrimarySlot( entity player, entity weapon )
{
	entity weaponInSlot0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	entity weaponInSlot1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )

	bool isInPrimarySlot = IsValid( weapon ) && (weapon == weaponInSlot0 || weapon == weaponInSlot1)
	return isInPrimarySlot
}

void function TryThankForLoot( entity player, entity wp, entity pingEnt, int pingType )
{
	if ( !IsValid( pingEnt ) )
		return

	if ( !GetCurrentPlaylistVarBool( "thank_for_loot_ping_enabled", true ) )
		return

	thread function() : ( player, wp, pingEnt )
	{
		EndSignal( wp, "OnDestroy" )
		
		entity pickedUpBy = expect entity( pingEnt.WaitSignal( "OnItemPickup" ).player )

		if ( !IsValid( pickedUpBy ) || player == pickedUpBy || !IsValid( wp ) )
			return

		Remote_CallFunction_NonReplay( pickedUpBy, "ServerCallback_PromptSayThanks", player )
	}()
}

void function CodeCallback_WeaponDropped( entity weapon )
{
	// unused
}

void function CodeCallback_WeaponLoadoutPickup( entity weapon )
{
	// unused
}
